#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <windows.h>  // è‹¥éœ€åœ¨ Windows CMD é¡¯ç¤º UTF-8 ä¸­æ–‡ï¼Œå¯ä¿ç•™ï¼Œå¦å‰‡å¯ç§»é™¤

// ============================================================================
// 1. çµæ§‹å®šç¾©ï¼ˆSudokuProblemã€SudokuDataHeaderï¼‰
// ----------------------------------------------------------------------------
// æè¿°ï¼šç”¨æ–¼äºŒé€²ä½æª”æ¡ˆå­˜å–çš„è³‡æ–™çµæ§‹ã€‚
// ----------------------------------------------------------------------------
typedef struct {
    int id;
    int data[9][9];
} SudokuProblem;

typedef struct {
    int numbers;   // æª”æ¡ˆä¸­åŒ…å«çš„é¡Œç›®æ•¸é‡
    int datasize;  // æ¯å€‹ SudokuProblem å ç”¨çš„ä½å…ƒçµ„å¤§å°
} SudokuDataHeader;


// ============================================================================
// 2. å…¨åŸŸè®Šæ•¸å®£å‘Š
// ----------------------------------------------------------------------------
// æè¿°ï¼šéŠæˆ²æ‰€éœ€çš„å…¨åŸŸè®Šæ•¸ï¼š
//       - boardï¼šåˆå§‹é¡Œç›®ç›¤é¢ï¼ˆå‹•æ…‹è‡ªæª”æ¡ˆè¼‰å…¥ï¼‰
//       - original_boardï¼šè¤‡è£½ä¸€ä»½ä¸å…è¨±ä¿®æ”¹çš„åŸå§‹ç›¤é¢
//       - player_boardï¼šç©å®¶ç›®å‰çš„ç›¤é¢
//       - answer_boardï¼šå®Œæ•´è§£ç­”ç›¤é¢
//       - error_countï¼šè¨˜éŒ„ç©å®¶éŒ¯èª¤æ¬¡æ•¸
//       - move_history[]ã€move_countï¼šå¯æ“´å……çš„è½å­ï¼å›å¾©è¨˜éŒ„
// ----------------------------------------------------------------------------

int board[9][9];           // ç”±æª”æ¡ˆè®€å…¥çš„ç•¶å‰é¡Œç›®
int original_board[9][9];  // åŸå§‹ç›¤é¢ï¼Œä¸èƒ½è¢«ç©å®¶æ”¹å‹•
int player_board[9][9];    // ç©å®¶ç›®å‰çš„ç›¤é¢
int answer_board[9][9];    // å®Œæ•´è§£ç­”ç›¤é¢

int error_count = 0;       // è¨˜éŒ„ç©å®¶éŒ¯èª¤æ¬¡æ•¸
int move_history[81][3];   // è½å­æ­·å²ï¼šæ¯ç­†è¨˜éŒ„ {row, col, oldValue}
int move_count = 0;        // æ­·å²è¨˜éŒ„ç­†æ•¸


// ============================================================================
// 3. å‡½å¼å®£å‘Šï¼ˆPrototypeï¼‰
// ----------------------------------------------------------------------------
// æè¿°ï¼šåœ¨ä½¿ç”¨ä¹‹å‰å…ˆå®£å‘Šæ‰€æœ‰è‡ªè¨‚å‡½å¼ã€‚
// ----------------------------------------------------------------------------

// æª”æ¡ˆè®€å–èˆ‡å¯«å…¥
int read_from_binary_file(int board[][9], const char* filename, int problem_index);
void save_to_binary_file(int board[][9], int problem_id, const char* filename, int is_append);

// è§£é¡Œå™¨ï¼ˆBacktracking Solverï¼‰
int solve(int puzzle[][9], int pos);
int solve_sudoku(int board[][9]);
int is_safe_place(int board[][9], int row, int col, int num);
int exists_in_row(int board[][9], int row, int num);
int exists_in_col(int board[][9], int col, int num);
int exists_in_box(int board[][9], int start_row, int start_col, int num);

// ç›¤é¢é¡¯ç¤º
void print_board(int board[][9]);
void print_board_beauty(int board[][9]);

// éŠæˆ²é‚è¼¯
void init_game(void);
int handle_input(void);
int is_complete(void);
int is_valid_solution(int puzzle[][9]);
int count_empty_cells(void);

// ç”¢ç”Ÿéš¨æ©Ÿç›¤é¢ï¼ˆå¯é¸ï¼‰
void generate_random_sudoku(int board[][9], int difficulty);


// ============================================================================
// 4. ä¸»ç¨‹å¼
// ----------------------------------------------------------------------------
// æè¿°ï¼šç¨‹å¼ä¸€å•Ÿå‹•æ™‚ï¼Œå…ˆè©¢å•ç©å®¶è¦è¼‰å…¥å“ªä¸€å€‹ç›¤é¢ï¼ˆ1~18ï¼‰ï¼Œç„¶å¾Œæ‰é€²è¡ŒéŠæˆ²ã€‚
// ----------------------------------------------------------------------------
int main() {
    // å¦‚æœéœ€è¦åœ¨ Windows CMD ä¸‹é¡¯ç¤ºä¸­æ–‡ï¼Œå°±ä¿ç•™ä»¥ä¸‹å…©è¡Œï¼›ä¸éœ€è¦å°±å¯ä»¥ç§»é™¤
    SetConsoleOutputCP(CP_UTF8);
    SetConsoleCP(CP_UTF8);

    int choice;
    char restart;

    do {
        // ---------- 4.1 åœ¨ç¨‹å¼ä¸€é–‹å§‹è©¢å•ã€Œè¦è¼‰å…¥å“ªä¸€å€‹ç›¤é¢ (1~18)ã€ ----------
        while (1) {
            printf("è«‹é¸æ“‡è¦è¼‰å…¥çš„é¡Œç›® (1~18)ï¼š");
            if (scanf("%d", &choice) != 1) {
                // æ¸…ç©ºéŒ¯èª¤è¼¸å…¥
                while (getchar() != '\n');
                printf("è¼¸å…¥éŒ¯èª¤ï¼Œè«‹è¼¸å…¥ 1~18 çš„æ•´æ•¸ã€‚\n");
                continue;
            }
            if (choice < 1 || choice > 18) {
                printf("è«‹è¼¸å…¥ 1~18 ä¹‹é–“çš„æ•¸å­—ã€‚\n");
                continue;
            }
            break;
        }

        // ---------- 4.2 å¾ sudoku.dat è®€å–ç©å®¶æ‰€é¸çš„é¡Œç›® (ç´¢å¼• = choice-1) ----------
        if (!read_from_binary_file(board, "sudoku.dat", choice - 1)) {
            printf("ç„¡æ³•è®€å– sudoku.dat æˆ–æŒ‡å®šé¡Œç›®ä¸å­˜åœ¨ï¼Œè«‹ç¢ºèªæª”æ¡ˆèˆ‡ç·¨è™Ÿã€‚\n");
            return 1;
        }

        // ---------- 4.3 åˆå§‹åŒ–éŠæˆ²ï¼ˆè¤‡è£½ç›¤é¢ã€æ±‚è§£ç­”æ¡ˆã€é‡ç½®è¨ˆæ•¸ï¼‰ ----------
        init_game();

        // ---------- 4.4 éŠæˆ²ä¸»è¿´åœˆï¼šé¡¯ç¤ºå‰©é¤˜ç©ºæ ¼ã€è™•ç†è¼¸å…¥ã€æª¢æŸ¥å‹è²  ----------
        while (error_count < 5) {
            // 4.4.1 å°å‡ºç©å®¶ç›®å‰ç›¤é¢
            printf("\nç•¶å‰ç›¤é¢ï¼š\n");
            print_board(player_board);

            // 4.4.2 å°å‡ºå‰©é¤˜ç©ºæ ¼æ•¸
            int remaining = count_empty_cells();
            printf("å‰©é¤˜ç©ºæ ¼æ•¸ï¼š%d\n", remaining);

            // 4.4.3 è™•ç†ç©å®¶è¼¸å…¥
            int result = handle_input();
            if (result == -1) {
                // ç©å®¶ä¸»å‹•è¼¸å…¥ 0 0 0 â†’ çµæŸæœ¬å±€
                printf("éŠæˆ²çµæŸã€‚\n");
                break;
            }
            else if (result == 1) {
                // ç©å®¶åˆæ³•å¡«äº†ä¸€å€‹æ•¸å­—ï¼ˆä¸è«–æ­£ç¢ºèˆ‡å¦éƒ½ç®—ä¸€æ¬¡ã€Œå·²è™•ç†ã€ï¼‰
                // æª¢æŸ¥æ˜¯å¦å·²å®Œæˆ
                if (is_complete()) {
                    if (is_valid_solution(player_board)) {
                        print_board(player_board);
                        printf("ğŸ‰ æ­å–œï¼ä½ å®Œæˆäº†æ•¸ç¨ï¼\n");
                    } else {
                        print_board(player_board);
                        printf("ç›¤é¢å·²å¡«æ»¿ï¼Œä½†ç­”æ¡ˆä¸æ­£ç¢ºï¼Œè«‹æª¢æŸ¥ï¼\n");
                    }
                    break;
                }
                // è‹¥å°šæœªå®Œæˆï¼Œè¿´åœˆç¹¼çºŒä¸‹ä¸€è¼ª
            }
            // å¦‚æœ result == 0 â†’ ç„¡æ•ˆè¼¸å…¥ï¼Œå·²åœ¨ handle_input() ä¸­æç¤ºï¼Œç›´æ¥ç¹¼çºŒè¿´åœˆ
        }

        // ---------- 4.5 è‹¥éŒ¯èª¤æ¬¡æ•¸é” 5 æ¬¡ï¼Œè‡ªå‹•çµæŸä¸¦é¡¯ç¤ºæ­£ç¢ºç­”æ¡ˆ ----------
        if (error_count >= 5) {
            printf("\nğŸ’¥ éŒ¯èª¤å¤ªå¤šæ¬¡ï¼ŒéŠæˆ²çµæŸï¼\n");
            printf("æ­£ç¢ºç­”æ¡ˆï¼š\n");
            print_board(answer_board);
        }

        // ---------- 4.6 è©¢å•ç©å®¶æ˜¯å¦è¦é‡æ–°é–‹å§‹ï¼ˆY/Nï¼‰ ----------
        while (1) {
            printf("\næ˜¯å¦è¦é‡æ–°é–‹å§‹ï¼Ÿ(Y/N)ï¼š");
            // æŠŠç·©å­˜æ›è¡Œç¬¦æ¸…æ‰ï¼Œæ‰ä¸æœƒç›´æ¥è®€åˆ°ä¸Šä¸€æ¬¡çš„æ›è¡Œ
            while (getchar() != '\n');
            restart = getchar();
            if (restart == 'Y' || restart == 'y') {
                break;  // ç”±å¤–å±¤ do-while é‡æ–°é–‹å§‹
            }
            else if (restart == 'N' || restart == 'n') {
                printf("æ„Ÿè¬éŠç©ï¼Œå†è¦‹ï¼\n");
                return 0;  // çµæŸæ•´å€‹ç¨‹å¼
            }
            else {
                printf("è«‹è¼¸å…¥ Y æˆ– Nã€‚\n");
                // è‹¥ä¸æ˜¯ Y/Nï¼Œç¹¼çºŒè©¢å•
            }
        }

    } while (1);

    return 0;
}


// ============================================================================
// 5. è®€å–äºŒé€²ä½æª”å‡½å¼
// ----------------------------------------------------------------------------
// æè¿°ï¼šæª”æ¡ˆæ ¼å¼ç‚ºï¼š
//
// [SudokuDataHeader][SudokuProblem #0][SudokuProblem #1]...
//
// è®€å‡º header å¾Œï¼Œå¯è·³åˆ°æŒ‡å®šé¡Œç›®ç´¢å¼•ä½ç½®é€²è¡Œ freadã€‚
// ----------------------------------------------------------------------------
int read_from_binary_file(int board[][9], const char* filename, int problem_index) {
    FILE *fp = fopen(filename, "rb");
    if (fp == NULL) {
        printf("ç„¡æ³•é–‹å•Ÿæª”æ¡ˆ %s é€²è¡Œè®€å–\n", filename);
        return 0;
    }

    // è®€å–æª”æ¡ˆæ¨™é ­
    SudokuDataHeader header;
    fread(&header, sizeof(header), 1, fp);
    if (header.numbers <= 0) {
        printf("æª”æ¡ˆ %s æ ¼å¼éŒ¯èª¤æˆ–æ²’æœ‰é¡Œç›®ã€‚\n", filename);
        fclose(fp);
        return 0;
    }
    printf("æª”æ¡ˆä¸­å…±æœ‰ %d å€‹æ•¸ç¨é¡Œç›®ã€‚\n", header.numbers);

    // æª¢æŸ¥ç´¢å¼•æ˜¯å¦æœ‰æ•ˆ
    if (problem_index < 0 || problem_index >= header.numbers) {
        printf("é¡Œç›®ç´¢å¼• %d è¶…å‡ºç¯„åœ (0 ~ %d)\n",
               problem_index, header.numbers - 1);
        fclose(fp);
        return 0;
    }

    // è·³åˆ°æŒ‡å®šé¡Œç›®ä½ç½®ï¼šheader å¾Œé¢ + offset
    fseek(fp, sizeof(header) + problem_index * header.datasize, SEEK_SET);

    // è®€å–ä¸€ç­† SudokuProblem
    SudokuProblem problem;
    fread(&problem, sizeof(problem), 1, fp);

    // è¤‡è£½åˆ° board
    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            board[i][j] = problem.data[i][j];
        }
    }

    printf("å·²è®€å–é¡Œç›® ID: %d\n", problem.id);
    fclose(fp);
    return 1;
}


// ============================================================================
// 6. è§£é¡Œå™¨ï¼šå›æº¯æ³•æ±‚è§£å®Œæ•´ç›¤é¢
// ----------------------------------------------------------------------------
// solve()ï¼šå¾ç¬¬ pos æ ¼ (0~80) é–‹å§‹ï¼Œè‹¥å¡«å®Œå‰‡å›å‚³ 1ï¼›å¦å‰‡å° 1ï½9 è©¦å¡«ï¼Œ
//           ä¸¦éè¿´ã€‚is_safe_place() ç­‰è¼”åŠ©å‡½å¼åˆ¤æ–·æ˜¯å¦åˆæ³•ã€‚
// ----------------------------------------------------------------------------
int solve(int puzzle[][9], int pos) {
    if (pos == 81) {
        return 1;  // å…¨éƒ¨å¡«å®Œ â†’ æˆåŠŸ
    }

    int row = pos / 9;
    int col = pos % 9;

    // å¦‚æœæ­¤æ ¼å·²æœ‰æ•¸å­—ç¬¦è™Ÿï¼Œå°±ç›´æ¥é€²åˆ°ä¸‹ä¸€æ ¼
    if (puzzle[row][col] != 0) {
        return solve(puzzle, pos + 1);
    }

    // å˜—è©¦å¡«å…¥ 1ï½9
    for (int num = 1; num <= 9; num++) {
        if (is_safe_place(puzzle, row, col, num)) {
            puzzle[row][col] = num;
            if (solve(puzzle, pos + 1)) {
                return 1;
            }
            // å›æº¯
            puzzle[row][col] = 0;
        }
    }

    // ç„¡æ³•å¡«å…¥ä»»ä½•æ•¸å­— â†’ å›æº¯å¤±æ•—
    return 0;
}


// ============================================================================
// 7. solve_sudoku(): éš¨æ©Ÿè§£å‡ºä¸€å€‹å®Œæ•´ç›¤é¢ï¼ˆç”¨æ–¼éš¨æ©Ÿç”¢é¡Œï¼‰
// ----------------------------------------------------------------------------
// æè¿°ï¼šå…ˆæ‰¾ç¬¬ä¸€å€‹ç©ºæ ¼ï¼Œå†éš¨æ©Ÿæ’åˆ— 1~9 çš„é †åºä¾åºå˜—è©¦ï¼Œç›´åˆ°æ•´ç›¤å¡«æ»¿ã€‚
//       é€šå¸¸æ­é… generate_random_sudoku() ä½¿ç”¨ã€‚
// ----------------------------------------------------------------------------
int solve_sudoku(int board[][9]) {
    int row, col;
    int found_empty = 0;

    for (row = 0; row < 9; row++) {
        for (col = 0; col < 9; col++) {
            if (board[row][col] == 0) {
                found_empty = 1;
                break;
            }
        }
        if (found_empty) break;
    }
    // å…¨ç›¤å¡«æ»¿
    if (!found_empty) {
        return 1;
    }

    // ç”¢ç”Ÿ 1~9 çš„éš¨æ©Ÿé †åº
    int nums[9] = {1,2,3,4,5,6,7,8,9};
    for (int i = 0; i < 9; i++) {
        int j = i + rand() % (9 - i);
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }

    // å˜—è©¦å¡«å…¥
    for (int i = 0; i < 9; i++) {
        int num = nums[i];
        if (is_safe_place(board, row, col, num)) {
            board[row][col] = num;
            if (solve_sudoku(board)) {
                return 1;
            }
            board[row][col] = 0;  // å›æº¯
        }
    }
    return 0;
}


// ============================================================================
// 8. æª¢æŸ¥æŸä¸€ä½ç½®å¡«å…¥ num æ˜¯å¦å®‰å…¨ï¼ˆä¸è¡çªï¼‰
// ----------------------------------------------------------------------------
// exists_in_row/col/box(): æª¢æŸ¥åŒä¸€è¡Œã€åŒä¸€åˆ—ã€åŒä¸€ 3Ã—3 å®æ–¹æ ¼å…§æ˜¯å¦å·²æœ‰ numã€‚
// ----------------------------------------------------------------------------
int is_safe_place(int board[][9], int row, int col, int num) {
    return !exists_in_row(board, row, num)
        && !exists_in_col(board, col, num)
        && !exists_in_box(board, row - row % 3, col - col % 3, num);
}

int exists_in_row(int board[][9], int row, int num) {
    for (int c = 0; c < 9; c++) {
        if (board[row][c] == num) return 1;
    }
    return 0;
}

int exists_in_col(int board[][9], int col, int num) {
    for (int r = 0; r < 9; r++) {
        if (board[r][col] == num) return 1;
    }
    return 0;
}

int exists_in_box(int board[][9], int start_row, int start_col, int num) {
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            if (board[start_row + i][start_col + j] == num) {
                return 1;
            }
        }
    }
    return 0;
}


// ============================================================================
// 9. ç”¢ç”Ÿéš¨æ©Ÿæ•¸ç¨é¡Œç›®ï¼ˆå¯é¸åŠŸèƒ½ï¼‰
// ----------------------------------------------------------------------------
// æè¿°ï¼šæ¸…ç©ºæ•´ç›¤ï¼Œå…ˆéš¨æ©Ÿæ”¾ 5 å€‹æ•¸å­—è§£å‡ºå®Œæ•´ç›¤é¢ï¼Œå†éš¨æ©ŸæŒ–æ´ã€‚
// difficulty: 1 (30~39 æ ¼æ´), 2 (40~49 æ ¼æ´), 3 (50~59 æ ¼æ´)ã€‚
// ----------------------------------------------------------------------------
void generate_random_sudoku(int board[][9], int difficulty) {
    // å…ˆæ¸…ç©ºç›¤é¢
    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            board[i][j] = 0;
        }
    }

    srand((unsigned int)time(NULL));

    // éš¨æ©Ÿæ”¾ 5 å€‹æ•¸å­—
    int placed = 0;
    while (placed < 5) {
        int r = rand() % 9;
        int c = rand() % 9;
        int num = 1 + rand() % 9;
        if (board[r][c] == 0 && is_safe_place(board, r, c, num)) {
            board[r][c] = num;
            placed++;
        }
    }

    // è§£å‡ºå®Œæ•´ç›¤é¢
    solve_sudoku(board);

    // æ ¹æ“šé›£åº¦æ±ºå®šè¦æŒ–æ‰å¤šå°‘æ ¼
    int cells_to_remove;
    switch (difficulty) {
        case 1: cells_to_remove = 30 + rand() % 10; break;
        case 2: cells_to_remove = 40 + rand() % 10; break;
        case 3: cells_to_remove = 50 + rand() % 10; break;
        default: cells_to_remove = 40; break;
    }

    while (cells_to_remove > 0) {
        int r = rand() % 9;
        int c = rand() % 9;
        if (board[r][c] != 0) {
            board[r][c] = 0;
            cells_to_remove--;
        }
    }
}


// ============================================================================
// 10. å°å‡ºç›¤é¢ï¼šç°¡æ˜“ç‰ˆ
// ----------------------------------------------------------------------------
// æè¿°ï¼šä»¥ã€Œ+â€”+â€”+â€”+ã€å½¢å¼é¡¯ç¤º 9Ã—9 ç›¤é¢ï¼Œç©ºæ ¼ç”¨ '_' è¡¨ç¤ºã€‚
// ----------------------------------------------------------------------------
void print_board(int board[][9]) {
    printf("\n +-------+-------+-------+\n");
    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            if (j % 3 == 0) printf(" | ");
            else printf(" ");
            if (board[i][j] == 0) {
                printf("_");
            } else {
                printf("%d", board[i][j]);
            }
        }
        printf(" |\n");
        if (i % 3 == 2) {
            printf(" +-------+-------+-------+\n");
        }
    }
}


// ============================================================================
// 11. å°å‡ºç›¤é¢ï¼šç¾åŒ–ç‰ˆï¼ˆUnicode æ¡†ç·šï¼‰
// ----------------------------------------------------------------------------
// æè¿°ï¼šä½¿ç”¨ â•” â•¦ â• â•‘ â•  â•¬ â•š â•© â•© ç­‰ç¬¦è™Ÿè®“ç›¤é¢çœ‹èµ·ä¾†æ›´æ¼‚äº®ã€‚
// ----------------------------------------------------------------------------
void print_board_beauty(int board[][9]) {
    printf("\n  â•”â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•—\n");
    for (int i = 0; i < 9; i++) {
        printf("  â•‘");
        for (int j = 0; j < 9; j++) {
            if (board[i][j] == 0) {
                printf(" Â· ");
            } else {
                printf(" %d ", board[i][j]);
            }
            if (j % 3 == 2 && j < 8) {
                printf("â•‘");
            }
        }
        printf("â•‘\n");
        if (i % 3 == 2 && i < 8) {
            printf("  â• â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•£\n");
        }
    }
    printf("  â•šâ•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•\n");
}


// ============================================================================
// 12. æ–°å¢éŠæˆ²åˆå§‹åŒ–å‡½å¼ï¼šinit_game()
// ----------------------------------------------------------------------------
// æè¿°ï¼šè¤‡è£½ board â†’ original_board / player_board / answer_boardï¼Œ
//       å‘¼å«è§£é¡Œå™¨ç®—å‡ºå®Œæ•´ç­”æ¡ˆï¼Œä¸¦é‡ç½® error_countã€move_countã€‚
// ----------------------------------------------------------------------------
void init_game(void) {
    // è¤‡è£½åˆå§‹é¡Œç›®åˆ°å„ç¨®ç›¤é¢
    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            original_board[i][j] = board[i][j];
            player_board[i][j] = board[i][j];
            answer_board[i][j] = board[i][j];
        }
    }

    // è¨ˆç®—å®Œæ•´ç­”æ¡ˆ
    solve(answer_board, 0);

    // é‡ç½®éŒ¯èª¤æ¬¡æ•¸èˆ‡å‹•ä½œæ­·å²
    error_count = 0;
    move_count = 0;

    printf("éŠæˆ²åˆå§‹åŒ–å®Œæˆï¼\n");
}


// ============================================================================
// 13. æ–°å¢è¼¸å…¥è™•ç†å‡½å¼ï¼šhandle_input()
// ----------------------------------------------------------------------------
// æè¿°ï¼šè®€å–ç©å®¶è¼¸å…¥ (row, col, num)ï¼Œè‹¥è¼¸å…¥ (0,0,0) å‰‡çµæŸï¼›
//       å¦å‰‡æª¢æŸ¥è¼¸å…¥æ˜¯å¦åˆæ³•ã€æ˜¯å¦å¡«åœ¨åŸå§‹æ ¼å­ã€æ˜¯å¦å·²å¡«éã€
//       å†æ¯”è¼ƒç­”æ¡ˆï¼Œè‹¥æ­£ç¢ºå¡«å…¥ player_board ä¸­ï¼Œå¦å‰‡ error_count++ã€‚
// ----------------------------------------------------------------------------
int handle_input(void) {
    int row, col, num;

    printf("è«‹è¼¸å…¥ è¡Œ åˆ— æ•¸å­— (1-9)ï¼Œæˆ–è¼¸å…¥ 0 0 0 çµæŸæœ¬å±€: ");
    if (scanf("%d %d %d", &row, &col, &num) != 3) {
        // æ¸…ç©ºéŒ¯èª¤ç·©å­˜
        while (getchar() != '\n');
        printf("è¼¸å…¥æ ¼å¼éŒ¯èª¤ï¼Œè«‹è¼¸å…¥ä¸‰å€‹æ•´æ•¸ã€‚\n");
        return 0;
    }

    // åˆ¤æ–·æ˜¯å¦çµæŸ
    if (row == 0 && col == 0 && num == 0) {
        return -1;  // ç©å®¶é¸æ“‡ä¸»å‹•çµæŸæœ¬å±€
    }

    // è¼¸å…¥ç¯„åœæª¢æŸ¥
    if (row < 1 || row > 9 || col < 1 || col > 9 || num < 1 || num > 9) {
        printf("è¼¸å…¥è¶…å‡ºç¯„åœï¼è«‹è¼¸å…¥ 1 ~ 9 ä¹‹é–“çš„æ•´æ•¸ã€‚\n");
        return 0;   // ç„¡æ•ˆè¼¸å…¥ï¼Œä¸ç®—éŒ¯èª¤
    }

    // è½‰æ›ç‚º 0-based ç´¢å¼•
    row--;
    col--;

    // æª¢æŸ¥æ˜¯å¦ç‚ºåŸå§‹é¡Œç›®æ ¼å­ï¼ˆä¸å¯ä¿®æ”¹ï¼‰
    if (original_board[row][col] != 0) {
        printf("è©²ä½ç½®ç‚ºåŸå§‹æ•¸å­—ï¼Œä¸èƒ½ä¿®æ”¹ï¼\n");
        return 0;
    }

    // æª¢æŸ¥æ˜¯å¦å·²å¡«é
    if (player_board[row][col] != 0) {
        printf("è©²ä½ç½®å·²ç¶“å¡«éæ•¸å­—ï¼\n");
        return 0;
    }

    // æª¢æŸ¥ç­”æ¡ˆæ˜¯å¦æ­£ç¢º
    if (answer_board[row][col] == num) {
        player_board[row][col] = num;
        printf("æ­£ç¢ºï¼\n");
    } else {
        error_count++;
        printf("éŒ¯èª¤ï¼éŒ¯èª¤æ¬¡æ•¸ï¼š%d\n", error_count);
    }

    return 1;  // è¡¨ç¤ºä¸€æ¬¡æœ‰æ•ˆè™•ç†
}


// ============================================================================
// 14. æ–°å¢éŠæˆ²å®Œæˆæª¢æŸ¥å‡½å¼ï¼šis_complete()
// ----------------------------------------------------------------------------
// æè¿°ï¼šåªè¦ player_board ä¸­æœ‰ä»»ä½•ä¸€å€‹ä½ç½®ç‚º 0ï¼Œå³ä»£è¡¨å°šæœªå®Œæˆï¼Œå›å‚³ 0ã€‚
//       è‹¥å…¨ç›¤çš†é 0ï¼Œå‰‡å›å‚³ 1ï¼ˆå®Œæˆï¼‰ã€‚
// ----------------------------------------------------------------------------
int is_complete(void) {
    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            if (player_board[i][j] == 0) {
                return 0;  // æœ‰ç©ºæ ¼
            }
        }
    }
    return 1;  // å…¨ç›¤å¡«æ»¿
}


// ============================================================================
// 15. æª¢æŸ¥ç›¤é¢åˆæ³•æ€§ï¼šis_valid_solution()
// ----------------------------------------------------------------------------
// æè¿°ï¼šé‡å°å·²å¡«æ»¿çš„ puzzleï¼Œæª¢æŸ¥æ¯ä¸€è¡Œã€æ¯ä¸€åˆ—ã€æ¯ä¸€ 3Ã—3 å°æ–¹æ ¼æ˜¯å¦éƒ½
//       å«æœ‰ 1~9 å„ä¸€æ¬¡ï¼Œè‹¥çš†ç¬¦åˆå‰‡å›å‚³ 1ï¼Œå¦å‰‡å›å‚³ 0ã€‚
// ----------------------------------------------------------------------------
int is_valid_solution(int puzzle[][9]) {
    int check[10];

    // æª¢æŸ¥æ¯ä¸€è¡Œ
    for (int i = 0; i < 9; i++) {
        for (int k = 1; k <= 9; k++) check[k] = 0;
        for (int j = 0; j < 9; j++) {
            int v = puzzle[i][j];
            if (v < 1 || v > 9 || check[v]) {
                return 0;
            }
            check[v] = 1;
        }
    }

    // æª¢æŸ¥æ¯ä¸€åˆ—
    for (int j = 0; j < 9; j++) {
        for (int k = 1; k <= 9; k++) check[k] = 0;
        for (int i = 0; i < 9; i++) {
            int v = puzzle[i][j];
            if (v < 1 || v > 9 || check[v]) {
                return 0;
            }
            check[v] = 1;
        }
    }

    // æª¢æŸ¥æ¯å€‹ 3Ã—3 å°æ–¹æ ¼
    for (int boxRow = 0; boxRow < 3; boxRow++) {
        for (int boxCol = 0; boxCol < 3; boxCol++) {
            for (int k = 1; k <= 9; k++) check[k] = 0;
            for (int i = 0; i < 3; i++) {
                for (int j = 0; j < 3; j++) {
                    int v = puzzle[boxRow * 3 + i][boxCol * 3 + j];
                    if (v < 1 || v > 9 || check[v]) {
                        return 0;
                    }
                    check[v] = 1;
                }
            }
        }
    }

    return 1;
}


// ============================================================================
// 16. è¨ˆç®—å‰©é¤˜ç©ºæ ¼æ•¸ï¼šcount_empty_cells()
// ----------------------------------------------------------------------------
// æè¿°ï¼šçµ±è¨ˆ player_board ä¸­å€¼ç‚º 0 çš„æ ¼å­æ•¸é‡ï¼Œä¸¦å›å‚³ã€‚
// ----------------------------------------------------------------------------
int count_empty_cells(void) {
    int count = 0;
    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            if (player_board[i][j] == 0) {
                count++;
            }
        }
    }
    return count;
}
